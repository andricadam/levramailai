// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
    output   = "../generated/prisma"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

model User {
    id String @id // Using Clerk's user ID, no default needed
    emailAddress String @unique
    firstName String
    lastName String
    imageUrl String?
    accounts Account[]
    stripeSubscription StripeSubscription?
    chatbotInteractions ChatbotInteraction[]
    chatFeedback ChatFeedback[]
    instantReplyFeedback InstantReplyFeedback[]
    chatAttachments ChatAttachment[]
    appConnections AppConnection[]
    labels UserLabel[]
}

model Account {
    id String @id @default(cuid())
    userId String

    accessToken String
    refreshToken String?
    expiresAt DateTime?
    provider String @default("aurinko") // 'google' | 'microsoft' | 'aurinko' (for backward compatibility)
    emailAddress String
    name String

    nextDeltaToken String?
    oramaIndex String?
    qaCacheIndex String?

    user User @relation(fields: [userId], references: [id])
    threads Thread[]
    emailAddresses EmailAddress[]
    chatAttachments ChatAttachment[]
    appConnections AppConnection[]
    
    @@unique([userId, emailAddress, provider], name: "unique_user_email_provider")
    @@index([provider])
}

model Thread {
    id              String   @id @default(cuid())
    subject         String
    lastMessageDate DateTime
    participantIds  String[]
    accountId       String
    account         Account  @relation(fields: [accountId], references: [id])

    done Boolean @default(false)

    inboxStatus Boolean @default(true)
    draftStatus Boolean @default(false)
    sentStatus  Boolean @default(false)
    spamStatus  Boolean @default(false)
    junkStatus  Boolean @default(false)

    emails Email[]
    threadLabels ThreadLabel[]

    @@index([accountId])
    @@index([done])
    @@index([inboxStatus])
    @@index([draftStatus])
    @@index([sentStatus])
    @@index([spamStatus])
    @@index([junkStatus])
    @@index([lastMessageDate])
}

model Email {
    id                   String                @id @default(cuid())
    threadId             String
    thread               Thread                @relation(fields: [threadId], references: [id])
    createdTime          DateTime
    lastModifiedTime     DateTime
    sentAt               DateTime
    receivedAt           DateTime
    internetMessageId    String
    subject              String
    sysLabels            String[]
    keywords             String[]
    sysClassifications   String[]
    sensitivity          Sensitivity           @default(normal)
    meetingMessageMethod MeetingMessageMethod?
    from                 EmailAddress          @relation("FromEmail", fields: [fromId], references: [id])
    fromId               String
    to                   EmailAddress[]        @relation("ToEmails")
    cc                   EmailAddress[]        @relation("CcEmails")
    bcc                  EmailAddress[]        @relation("BccEmails")
    replyTo              EmailAddress[]        @relation("ReplyToEmails")
    hasAttachments       Boolean
    body                 String?
    bodySnippet          String?
    attachments          EmailAttachment[]
    inReplyTo            String?
    references           String?
    threadIndex          String?
    internetHeaders      Json[]
    nativeProperties     Json?
    folderId             String?
    omitted              String[]

    emailLabel EmailLabel @default(inbox)
    priority EmailPriority @default(medium)
    autoReplyDraft String?
    embeddings Float[] // Vector embeddings for pgvector search

    @@index([threadId])
    @@index([emailLabel])
    @@index([sentAt])
    @@index([priority])
}

enum EmailLabel {
    inbox
    sent
    draft
    spam
    junk
}

enum EmailPriority {
    high
    medium
    low
}

model EmailAddress {
    id            String  @id @default(cuid())
    name          String?
    address       String
    raw           String?
    sentEmails    Email[] @relation("FromEmail")
    receivedTo    Email[] @relation("ToEmails")
    receivedCc    Email[] @relation("CcEmails")
    receivedBcc   Email[] @relation("BccEmails")
    replyToEmails Email[] @relation("ReplyToEmails")

    accountId String
    account   Account @relation(fields: [accountId], references: [id])

    @@unique([accountId, address])
}

model EmailAttachment {
    id              String  @id @default(cuid())
    name            String
    mimeType        String
    size            Int
    inline          Boolean
    contentId       String?
    content         String?
    contentLocation String?
    Email           Email   @relation(fields: [emailId], references: [id])
    emailId         String
}

enum Sensitivity {
    normal
    private
    personal
    confidential
}

enum MeetingMessageMethod {
    request
    reply
    cancel
    counter
    other
}

model ChatbotInteraction {
    id String @id @default(cuid())
    day    String
    userId String
    count  Int @default(1)
    user User @relation(fields: [userId], references: [id])

    @@unique([day, userId])
    @@index([userId])
}

model StripeSubscription {
    userId           String   @id @unique
    subscriptionId   String   @unique
    customerId       String
    productId        String
    priceId          String
    currentPeriodEnd DateTime
    updatedAt        DateTime @updatedAt

    user User @relation(fields: [userId], references: [id])

    @@index([userId])
    @@index([subscriptionId])
}

model ChatFeedback {
    id String @id @default(cuid())
    userId String
    accountId String
    query String
    response String
    retrievedEmails String[] // Email IDs or thread IDs that were retrieved
    helpful Boolean? // true/false/null (null = implicit feedback)
    correctedQuery String? // If user rephrased the query
    interactionType String @default("explicit") // 'explicit', 'implicit', 'correction'
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id])

    @@index([userId, accountId])
    @@index([helpful])
    @@index([createdAt])
    @@index([interactionType])
}

model InstantReplyFeedback {
    id String @id @default(cuid())
    userId String
    accountId String
    threadId String?
    
    // Type of generation: "instant-reply" or "compose"
    type String @default("instant-reply") // "instant-reply" or "compose"
    
    // Context used for generation
    emailContext String
    userPrompt String? // For compose: the user's description/prompt
    originalEmailId String?
    
    // Generated vs actual
    generatedReply String // The AI-generated reply/email
    finalSentReply String? // The actual reply that was sent (after user edits)
    
    // Metadata
    wasEdited Boolean @default(false)
    editSimilarity Float?
    modelVersion String? // Which model version generated this
    
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    
    user User @relation(fields: [userId], references: [id])
    
    @@index([userId, accountId])
    @@index([threadId])
    @@index([createdAt])
    @@index([type])
}

model ChatAttachment {
    id String @id @default(cuid())
    userId String
    accountId String
    
    fileName String
    mimeType String
    size Int
    fileUrl String? // For permanent storage
    extractedText String
    textEmbeddings Float[] // Optional - can be empty array if not needed
    
    // Knowledge base flag
    inKnowledgeBase Boolean @default(false)
    
    // Metadata
    uploadedAt DateTime @default(now())
    indexedAt DateTime? // When added to Orama
    
    user User @relation(fields: [userId], references: [id])
    account Account @relation(fields: [accountId], references: [id])
    
    @@index([userId, accountId])
    @@index([inKnowledgeBase])
    @@index([uploadedAt])
}

// App Integration Models
model AppConnection {
    id String @id @default(cuid())
    userId String
    accountId String? // Optional: link to email account if relevant
    
    appType String // 'sharepoint' | 'google_drive' | 'google_calendar'
    appName String // Display name
    
    // OAuth tokens (encrypted in production)
    accessToken String
    refreshToken String?
    expiresAt DateTime?
    
    // Connection metadata
    connectedAt DateTime @default(now())
    lastSyncedAt DateTime?
    syncStatus String @default("pending") // 'pending' | 'syncing' | 'synced' | 'error'
    syncError String?
    
    // Settings
    enabled Boolean @default(true)
    syncFrequency String @default("daily") // 'hourly' | 'daily' | 'weekly'
    
    user User @relation(fields: [userId], references: [id])
    account Account? @relation(fields: [accountId], references: [id])
    
    syncedItems SyncedItem[]
    
    @@unique([userId, appType])
    @@index([userId])
    @@index([appType])
    @@index([syncStatus])
}

model SyncedItem {
    id String @id @default(cuid())
    connectionId String
    
    // Item identification
    externalId String // ID from the external app
    itemType String // 'file' | 'document' | 'event' | 'folder'
    title String
    content String // Extracted text content
    url String? // Link to original item
    
    // Metadata
    mimeType String?
    size Int?
    modifiedAt DateTime?
    
    // Indexing
    indexedAt DateTime?
    embeddings Float[] // For vector search
    
    connection AppConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
    
    @@unique([connectionId, externalId])
    @@index([connectionId])
    @@index([itemType])
    @@index([indexedAt])
}

model UserLabel {
    id          String   @id @default(cuid())
    userId      String
    name        String
    description String?
    color       String   @default("#6b7280")
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    threadLabels ThreadLabel[]
    
    @@index([userId])
}

model ThreadLabel {
    id        String   @id @default(cuid())
    threadId String
    labelId  String
    
    thread    Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
    label     UserLabel @relation(fields: [labelId], references: [id], onDelete: Cascade)
    
    @@unique([threadId, labelId])
    @@index([threadId])
    @@index([labelId])
}
